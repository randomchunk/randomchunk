#!/bin/bash

# extract a piece from a file

OPTIND=""
infile=""
outfile=""
size=""
minsize=0
maxsize=""
randomsize=0
append=""
#set this to 1 to output debugging statements
DEBUG=0

function errquit 
{
	if [[ $DEBUG == 1 ]]
	then
		echo $@
	else
		echo "Error"
	fi
	exit 1
}

function debug
{
	if [[ $DEBUG == 1 ]]
	then
		echo $@
	fi
}

# use getopts to collect parameters
while getopts "i:o:s:n:x:p:raq" OPTION
do
  case $OPTION in
	i)
	  infile="$OPTARG"
	  debug "Input file is: '$infile'"
	  ;;
	o)
	  outfile="$OPTARG"
	  debug "Output file is: '$outfile'"
	  ;;
	s)
		size=$((OPTARG))
	  debug "Chunk size is: '$size'"
	  ;;
	n)
		minsize=$((OPTARG))
	  debug "Min chunk size is: '$minsize'"
	  ;;
	x)
		maxsize=$((OPTARG))
	  debug "Max chunk size is: '$maxsize'"
	  ;;
	r)
	  randomsize=1
	  debug "A random-sized subset of the file will be chosen."
	  ;;
	a)
	  append="conv=notrunc oflag=append"
	  # will append instead of overwrite
	  ;;
	q)
	  ok_if_short=1
	  # just copy entire file if it is not large enough
	  ;;
	p)
	    #seeding with non-numeric values always yields 20034 
	    seed="$OPTARG"
	    RANDOM="$seed"
		;;
  esac
done

if [ -z "$infile" ] || [ -z $outfile ]
then
	echo "randomchunk -- extract a random chunk from a large file"
	echo "usage: randomchunk -i infile -o outfile -s size"
	echo "	-i infile	file to read chunk from"
	echo "	-o outfile	file to write chunk to"
	echo "	-s size		size (in kilobytes) of output"
	echo "	-p seed		seed for the PRNG"
	echo "	-r		make a random size chunk"
	echo "	-n		minimum size for -r (in KB)"
	echo "	-x		maximum size for -r (in KB)"
	echo "	-a		append to ouput file rather than overwriting"
	echo "	-q		if file is not large enough, just copy entire file"
	echo "	-v		be verbose"
	echo ""
  exit 1
fi

if [[ "$infile" == "RND" ]]
then
	infile=$(pickrandom ~/corpora)
fi
debug "Infile is: '$infile'"

# get file size
infilesize=$(( $(stat -c%s "$infile") / 1024 ))

if [ ! -z $size ]
then
	if (( $size < 0 ))
	then
	  errquit "Size cannot be negative. ($size)"
	elif (( $size > $infilesize ))
	then
		if [[ $ok_if_short == 1 ]]
		then
			debug "File is too small for this size so we will copy the whole thing. (-q)"
			cp -v "$infile" $outfile
			exit 0
		fi

	  errquit "Size ${size}K requested, but '$infile' is only ${infilesize}K bytes, aborting." 

	elif (( $minsize > 0 )) || [ ! -z $maxsize ] || [[ $randomsize == 1 ]]
	then
  		debug "WARNING: explicit size argument (${size}K) OVERRIDES random/min/max settings."
	fi
fi

if [ ! -z $maxsize ]
then
  #does ascii comparison instead of int comparison. 
  #so maxsize 28 is "larger" than 275 for example. 
	if [ "$maxsize" > "$infilesize" ]
	then
	  errquit "Maxsize ${maxsize}K is greater than ${infilesize}K, aborting." 
	elif (( $minsize > $maxsize ))
	then
	  errquit "Minsize (${minsize}K) cannot be larger than maxsize (${maxsize}K), aborting." 
	fi
else
  maxsize=$infilesize
fi

if [ -f "$infile" ]
then
	if [ ! -r "$infile" ]
	then
	  errquit "Infile '$infile' exists but is not readable." 
	fi
  else
	  errquit "Infile '$infile' does not exist." 
fi

if [[ $randomsize == 1 ]]
then
	size=0
  	while (( $size < $minsize )) || (( $size > $maxsize ))
  	do
		size=$(( RANDOM % infilesize ))
	done
  	
	debug "Random size: ${size}K"
fi

skip=$(( RANDOM % ( infilesize - size ) ))
debug "Skipping $skip KB out of $infilesize and reading $size KB to $outfile"
if dd if=$infile of=$outfile bs=1024 count=$size skip=$skip $append 2> /dev/null
then
	hash=$(sha256sum $outfile | cut -d " " -f 1)
	echo "$infile,$outfile,$size,$skip,$hash" >> rchunk.log
else
	echo "$infile,$outfile,$size,$skip,ERROR" >> rchunk.log
fi
